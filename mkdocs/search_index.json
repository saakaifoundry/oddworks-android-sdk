{
    "docs": [
        {
            "location": "/", 
            "text": "Oddworks SDK for Android\n\n\nDocument version: February 3, 2016\n\nSDK Version: beta-1.0.0\n\n\nThe Oddworks SDK for Android is a wrapper for the Odd Networks...\n\n\nFeatures\n\n\nThe Oddworks SDK for Android supports the following features:\n\n\n\n\nA wrapper for the Odd API that parses returned JSON into Java Objects\n\n\nA data store for objects received from the API\n\n\nA way to post metrics back to the API\n\n\n\n\nIntended Audience\n\n\nThis guide assumes that you have the necessary Java and Android development skills to work successfully with Oddworks for Android. You should know how to build and compile Android applications using Android Studio and the latest tools from the Android Developers Kit.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#oddworks-sdk-for-android", 
            "text": "Document version: February 3, 2016 \nSDK Version: beta-1.0.0  The Oddworks SDK for Android is a wrapper for the Odd Networks...", 
            "title": "Oddworks SDK for Android"
        }, 
        {
            "location": "/#features", 
            "text": "The Oddworks SDK for Android supports the following features:   A wrapper for the Odd API that parses returned JSON into Java Objects  A data store for objects received from the API  A way to post metrics back to the API", 
            "title": "Features"
        }, 
        {
            "location": "/#intended-audience", 
            "text": "This guide assumes that you have the necessary Java and Android development skills to work successfully with Oddworks for Android. You should know how to build and compile Android applications using Android Studio and the latest tools from the Android Developers Kit.", 
            "title": "Intended Audience"
        }, 
        {
            "location": "/overview/", 
            "text": "About Oddworks\n\n\nOddworks is, at its core, a Video Management System (VMS). It provides a central location to organize media and configure the devices that serve it.\n\n\nOddworks Entities\n\n\nOddworks has a handful of specific entity types that are used in concert to construct media applications. No matter which Online Video Provider (OVP) is used to provide media to Oddworks, the data will be massaged into one of these standardized objects. Our thought is that consumer applications should not need to change when adding a new OVP or changing where a video is stored.\n\n\nconfig\n\n\nThe \nconfig\n entity will contain device-specific configuration data.\n\n\nvideo and liveStream\n\n\nThe \nvideo\n and \nliveStream\n entities are the media objects that are the meat and potatoes of Odd Networks. If the media being served is a linear or live stream, it will be of type \nliveStream\n. If the media is an on-demand stream then it will be of type \nvideo\n.\n\n\npromotion\n\n\nThe \npromotion\n entity is an object that is essentially the same as a \nvideo\n or \nliveStream\n without the stream.\n\n\ncollection\n\n\nA \ncollection\n entity is an object that contains other entities.\n\n\nview\n\n\nA \nview\n entity is an object that can contain other entities through user-defined custom relationships.\n\n\nFor a more in-depth look at all entities that you can interact with through the SDK and their properties, \nlook here\n.", 
            "title": "Oddworks Overview"
        }, 
        {
            "location": "/overview/#about-oddworks", 
            "text": "Oddworks is, at its core, a Video Management System (VMS). It provides a central location to organize media and configure the devices that serve it.", 
            "title": "About Oddworks"
        }, 
        {
            "location": "/overview/#oddworks-entities", 
            "text": "Oddworks has a handful of specific entity types that are used in concert to construct media applications. No matter which Online Video Provider (OVP) is used to provide media to Oddworks, the data will be massaged into one of these standardized objects. Our thought is that consumer applications should not need to change when adding a new OVP or changing where a video is stored.", 
            "title": "Oddworks Entities"
        }, 
        {
            "location": "/overview/#config", 
            "text": "The  config  entity will contain device-specific configuration data.", 
            "title": "config"
        }, 
        {
            "location": "/overview/#video-and-livestream", 
            "text": "The  video  and  liveStream  entities are the media objects that are the meat and potatoes of Odd Networks. If the media being served is a linear or live stream, it will be of type  liveStream . If the media is an on-demand stream then it will be of type  video .", 
            "title": "video and liveStream"
        }, 
        {
            "location": "/overview/#promotion", 
            "text": "The  promotion  entity is an object that is essentially the same as a  video  or  liveStream  without the stream.", 
            "title": "promotion"
        }, 
        {
            "location": "/overview/#collection", 
            "text": "A  collection  entity is an object that contains other entities.", 
            "title": "collection"
        }, 
        {
            "location": "/overview/#view", 
            "text": "A  view  entity is an object that can contain other entities through user-defined custom relationships.  For a more in-depth look at all entities that you can interact with through the SDK and their properties,  look here .", 
            "title": "view"
        }, 
        {
            "location": "/setup/", 
            "text": "Integrate the Oddworks SDK\n\n\nOur SDK is built and hosted via \nJitpack\n. Include Jitpack in the \nrepositories\n section of your app module's \nbuild.gradle\n file:\n\n\n// app/build.gradle\n\nrepositories {\n    // ...\n    maven { url \nhttps://jitpack.io\n }\n}\n\n\n\n\nNow in the  \ndependencies\n section of your app module's \nbuild.gradle\n file add the Oddworks SDK:\n\n\n// app/build.gradle\n\ndependencies {\n    // ...\n    compile \ncom.github.oddnetworks:OddWorksDeviceSDK:beta-1.0.0\n\n}\n\n\n\n\nThere's one more \noptional\n thing you can do to your application's \nbuild.gradle\n file that will be used in the next step. The SDK expects an app version when it's being initialized. One option would be to use your app module's \nBuildConfig.VERSION_NAME\n. Another might be to send your git revision.\n\n\n// app/build.gradle\n\nandroid {\n    // ...\n    defaultConfig {\n        // ...\n        resValue \nstring\n, \ngit_revision\n, gitRevision()\n    }\n    // ...\n}\n\n// ...\n\ndef gitRevision() {\n    def cmd = \ngit rev-parse --short HEAD\n\n    return cmd.execute().text.trim()\n}\n\n\n\n\nSync your project with Gradle files and you will have the OddworksDeviceSDK added to your External Libraries.\n\n\nConfigure Your Access Token\n\n\nThe SDK also will need an access token to use when accessing the API. For instructions on how to receive your own access token check out our \nAPI Guide\n.  Create a file in \napp/res/values/\n called \nsdk_strings.xml\n.\n\n\n    \n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n    \nresources\n\n        \nstring name=\nx_access_token\nyour-access-token-here\n/string\n\n    \n/resources\n\n\n\n\n\nFor this guide we'll use the sample access token below, which accesses NASA content.\n\n\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ2ZXJzaW9uIjoxLCJkZXZpY2VJRCI6IjBhODFjNmEwLWJiYjUtMTFlNS05ZWY4LWNiYmI0OWM4OTI1NiIsInNjb3BlIjpbImRldmljZSJdLCJpYXQiOjE0NTI4ODIxOTR9.iM26knCfqoPggNMeEUgH6_sW1kpwqmE9Hrso02g4LyQ\n\n\n\n\nWe strongly recommend adding any file that contains sensitive information to your project's \n.gitignore\n file. This access token should be kept private and not checked in to version control. Anyone who has your access token will be able to fetch your data.", 
            "title": "Library and Project Setup"
        }, 
        {
            "location": "/setup/#integrate-the-oddworks-sdk", 
            "text": "Our SDK is built and hosted via  Jitpack . Include Jitpack in the  repositories  section of your app module's  build.gradle  file:  // app/build.gradle\n\nrepositories {\n    // ...\n    maven { url  https://jitpack.io  }\n}  Now in the   dependencies  section of your app module's  build.gradle  file add the Oddworks SDK:  // app/build.gradle\n\ndependencies {\n    // ...\n    compile  com.github.oddnetworks:OddWorksDeviceSDK:beta-1.0.0 \n}  There's one more  optional  thing you can do to your application's  build.gradle  file that will be used in the next step. The SDK expects an app version when it's being initialized. One option would be to use your app module's  BuildConfig.VERSION_NAME . Another might be to send your git revision.  // app/build.gradle\n\nandroid {\n    // ...\n    defaultConfig {\n        // ...\n        resValue  string ,  git_revision , gitRevision()\n    }\n    // ...\n}\n\n// ...\n\ndef gitRevision() {\n    def cmd =  git rev-parse --short HEAD \n    return cmd.execute().text.trim()\n}  Sync your project with Gradle files and you will have the OddworksDeviceSDK added to your External Libraries.", 
            "title": "Integrate the Oddworks SDK"
        }, 
        {
            "location": "/setup/#configure-your-access-token", 
            "text": "The SDK also will need an access token to use when accessing the API. For instructions on how to receive your own access token check out our  API Guide .  Create a file in  app/res/values/  called  sdk_strings.xml .       ?xml version= 1.0  encoding= utf-8 ? \n     resources \n         string name= x_access_token your-access-token-here /string \n     /resources   For this guide we'll use the sample access token below, which accesses NASA content.  eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ2ZXJzaW9uIjoxLCJkZXZpY2VJRCI6IjBhODFjNmEwLWJiYjUtMTFlNS05ZWY4LWNiYmI0OWM4OTI1NiIsInNjb3BlIjpbImRldmljZSJdLCJpYXQiOjE0NTI4ODIxOTR9.iM26knCfqoPggNMeEUgH6_sW1kpwqmE9Hrso02g4LyQ  We strongly recommend adding any file that contains sensitive information to your project's  .gitignore  file. This access token should be kept private and not checked in to version control. Anyone who has your access token will be able to fetch your data.", 
            "title": "Configure Your Access Token"
        }, 
        {
            "location": "/getting_started/", 
            "text": "Application Activity and Android Manifest\n\n\nWe want to extend the \nApplication\n class so that we can handle global state. Create a new Java class in your app's main package naming it whatever you like, we'll call ours \nOddApp\n. This will be a singleton class so we'll configure it as such:\n\n\npackage sample.oddworks.com.myoddworksapplication;\n\nimport android.app.Application;\n\nimport io.oddworks.device.model.OddView;\nimport io.oddworks.device.request.RestServiceProvider;\nimport io.oddworks.device.service.OddStore;\n\npublic class OddApp extends Application {\n    private static OddApp singleton;\n    public static OddApp getInstance() {\n        return singleton;\n    }\n\n    private OddView homeView;\n    private OddView menuView;\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        singleton = this;\n\n        RestServiceProvider.init(getApplicationContext(),\n                getString(R.string.x_access_token),\n                getString(R.string.git_revision));\n        // Alternatively you could use BuildConfig.VERSION_NAME instead of R.string.git_revision\n    }\n\n    public OddView getHomeView() {\n        return homeView;\n    }\n\n    public void setHomeView(OddView homeView) {\n        OddStore.getInstance().storeObjects(homeView.getIncluded());\n        this.homeView = homeView;\n    }\n}\n\n\n\n\nWe've finally written the first code that interacts with the SDK. You'll notice we utilize the \nOddView\n, \nRestServiceProvider\n, and \nOddStore\n classes. The \nOddView\n class is the main way large amounts of data are passed from the SDK to the app. We have a view that represents all of the data needed to construct a dynamic menu/navigation called \nmenuView\n and one for all of the content shown on application load called \nhomeView\n. The \nRestServiceProvider\n initializes everything we need in order to interact with the API. In the setter methods for each view we're utilizing the \nOddStore\n so that we can minimize API calls if the \nhomeView\n and \nmenuView\n variables get released from memory.\n\n\nIn our \nAndroidManifest\n file we'll add this new class by adding it as the name attribute to the opening \napplication\n tag. By placing this attribute in the XML \nOddApp\n will run when the app first initializes.\n\n\napplication\n    android:name=\n.OddApp\n\n    android:allowBackup=\ntrue\n\n    android:icon=\n@mipmap/ic_launcher\n\n    android:label=\n@string/app_name\n\n    android:supportsRtl=\ntrue\n\n    android:theme=\n@style/AppTheme\n \n\n\n/application\n\n\n\n\n\nLauncher Activity\n\n\nWe need an Activity to handle fetching initial data from the API when the application is first launched. We'll create a new Empty Activity called \nSplashActivity\n with a corresponding \nactivity_splash\n layout file, making sure to check the \"Launcher Activity\" option. Make sure to add an attribute to this Activity in the \nAndroidManifest\n that disables it from history:\n\n\nactivity\n    android:name=\n.SplashActivity\n\n    android:noHistory=\ntrue\n\n    \nintent-filter\n\n        \naction android:name=\nandroid.intent.action.MAIN\n /\n\n        \ncategory android:name=\nandroid.intent.category.LAUNCHER\n /\n\n    \n/intent-filter\n\n\n/activity", 
            "title": "Configuring your App"
        }, 
        {
            "location": "/getting_started/#application-activity-and-android-manifest", 
            "text": "We want to extend the  Application  class so that we can handle global state. Create a new Java class in your app's main package naming it whatever you like, we'll call ours  OddApp . This will be a singleton class so we'll configure it as such:  package sample.oddworks.com.myoddworksapplication;\n\nimport android.app.Application;\n\nimport io.oddworks.device.model.OddView;\nimport io.oddworks.device.request.RestServiceProvider;\nimport io.oddworks.device.service.OddStore;\n\npublic class OddApp extends Application {\n    private static OddApp singleton;\n    public static OddApp getInstance() {\n        return singleton;\n    }\n\n    private OddView homeView;\n    private OddView menuView;\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        singleton = this;\n\n        RestServiceProvider.init(getApplicationContext(),\n                getString(R.string.x_access_token),\n                getString(R.string.git_revision));\n        // Alternatively you could use BuildConfig.VERSION_NAME instead of R.string.git_revision\n    }\n\n    public OddView getHomeView() {\n        return homeView;\n    }\n\n    public void setHomeView(OddView homeView) {\n        OddStore.getInstance().storeObjects(homeView.getIncluded());\n        this.homeView = homeView;\n    }\n}  We've finally written the first code that interacts with the SDK. You'll notice we utilize the  OddView ,  RestServiceProvider , and  OddStore  classes. The  OddView  class is the main way large amounts of data are passed from the SDK to the app. We have a view that represents all of the data needed to construct a dynamic menu/navigation called  menuView  and one for all of the content shown on application load called  homeView . The  RestServiceProvider  initializes everything we need in order to interact with the API. In the setter methods for each view we're utilizing the  OddStore  so that we can minimize API calls if the  homeView  and  menuView  variables get released from memory.  In our  AndroidManifest  file we'll add this new class by adding it as the name attribute to the opening  application  tag. By placing this attribute in the XML  OddApp  will run when the app first initializes.  application\n    android:name= .OddApp \n    android:allowBackup= true \n    android:icon= @mipmap/ic_launcher \n    android:label= @string/app_name \n    android:supportsRtl= true \n    android:theme= @style/AppTheme    /application", 
            "title": "Application Activity and Android Manifest"
        }, 
        {
            "location": "/getting_started/#launcher-activity", 
            "text": "We need an Activity to handle fetching initial data from the API when the application is first launched. We'll create a new Empty Activity called  SplashActivity  with a corresponding  activity_splash  layout file, making sure to check the \"Launcher Activity\" option. Make sure to add an attribute to this Activity in the  AndroidManifest  that disables it from history:  activity\n    android:name= .SplashActivity \n    android:noHistory= true \n     intent-filter \n         action android:name= android.intent.action.MAIN  / \n         category android:name= android.intent.category.LAUNCHER  / \n     /intent-filter  /activity", 
            "title": "Launcher Activity"
        }, 
        {
            "location": "/data_models/", 
            "text": "OddObject\n\n\nThe \nOddObject\n class is a superclass of many other data models in the SDK. It's children include \nOddView\n, \nOddCollection\n, \nMedia\n, \nArticle\n, \nEvent\n, \nExternal\n, and \nPromotion\n. It provides many convienence methods that help you sort through data received from the API such as \ngetIncluded\n, \ngetIncludedByType\n, \ngetIncludedByRelationship\n, \ngetIdentifiersByRelationship\n, and \nfindIncludedByIdentifier\n. These getter methods can return any combination of \nOddObject\n's subclass objects depending on how you've configured your data on the Oddworks dashboard.\n\n\nOddView\n\n\nThe \nOddView\n class makes it possible to retreive and store large amounts of data from the API with a single call. This view contains \"relationships\" and \"included\" pieces of data that can be accessed via \nOddObject\n's convienence methods. When constructing applications you may find it helpful to package things such as your navigation and the initial data shown on application load into an \nOddView\n.\n\n\nOddCollection\n\n\nThe \nOddCollection\n class makes it possible to group together other entities for explicit display. Depending on how you configure your Collection on the Oddworks dashboard it can contain a description, a preview image, a release date, a title, an ID, a related \nIdentifier\n object, relationships, included \nOddObject\ns, and a type.\n\n\nMedia\n\n\nThe \nMedia\n class can represent any type of playable media to users. This could be a VOD, HLS Stream, DASH Stream, etc. Depending on how you configure your Media on the Oddworks dashboard it can contain a description, a duration, ad support information, a preview image, an explicitly stated player to use, a release date, sharing information, a title, a URL, an ID, a related \nIdentifier\n object, relationships, included \nOddObject\ns (such as related videos), and a type.\n\n\nArticle\n\n\nThe \nArticle\n class represents a news item that can be displayed in the application. Depending on how you configure your Article on the Oddworks dashboard it can contain a description, a title, a preview image, a URL to link to, a category, a source, a created at timestamp, a related \nIdentifier\n object, relationships, included \nOddObject\ns (such as related articles), and a type.\n\n\nEvent\n\n\nThe \nEvent\n class is similar to the \nArticle\n class but it is used specifically for informing users of events that will or have occured. Depending on how you configure your Event on the Oddworks dashboard it can contain a description, a title, a preview image, a URL to link to, a category, a source, a created at timestamp, a start time, an end time, a location, a related \nIdentifier\n object, relationships, included \nOddObject\ns (such as related events), and a type. There is also the convienence methos of \nisMultiDayEvent\n in case you need to update your UI based on datetime formatting.\n\n\nExternal\n\n\nThe \nExternal\n class is used to handle any webpage you'd like to embed in your application. Depending on how you configure your External on the Oddworks dashboard it can contain a description, a title, a preview image, a URL to link to, a related \nIdentifier\n object, relationships, included \nOddObject\ns (such as related externals), and a type.\n\n\nPromotion\n\n\nThe \nPromotion\n class is used to handle any type of promotion you may want to put in the application. Depending on how you configure your Promotion on the Oddworks dashboard it can contain a description, a title, a preview image, a related \nIdentifier\n object, relationships, included \nOddObject\ns (such as related externals), and a type.", 
            "title": "Understanding the SDK Data Models"
        }, 
        {
            "location": "/data_models/#oddobject", 
            "text": "The  OddObject  class is a superclass of many other data models in the SDK. It's children include  OddView ,  OddCollection ,  Media ,  Article ,  Event ,  External , and  Promotion . It provides many convienence methods that help you sort through data received from the API such as  getIncluded ,  getIncludedByType ,  getIncludedByRelationship ,  getIdentifiersByRelationship , and  findIncludedByIdentifier . These getter methods can return any combination of  OddObject 's subclass objects depending on how you've configured your data on the Oddworks dashboard.", 
            "title": "OddObject"
        }, 
        {
            "location": "/data_models/#oddview", 
            "text": "The  OddView  class makes it possible to retreive and store large amounts of data from the API with a single call. This view contains \"relationships\" and \"included\" pieces of data that can be accessed via  OddObject 's convienence methods. When constructing applications you may find it helpful to package things such as your navigation and the initial data shown on application load into an  OddView .", 
            "title": "OddView"
        }, 
        {
            "location": "/data_models/#oddcollection", 
            "text": "The  OddCollection  class makes it possible to group together other entities for explicit display. Depending on how you configure your Collection on the Oddworks dashboard it can contain a description, a preview image, a release date, a title, an ID, a related  Identifier  object, relationships, included  OddObject s, and a type.", 
            "title": "OddCollection"
        }, 
        {
            "location": "/data_models/#media", 
            "text": "The  Media  class can represent any type of playable media to users. This could be a VOD, HLS Stream, DASH Stream, etc. Depending on how you configure your Media on the Oddworks dashboard it can contain a description, a duration, ad support information, a preview image, an explicitly stated player to use, a release date, sharing information, a title, a URL, an ID, a related  Identifier  object, relationships, included  OddObject s (such as related videos), and a type.", 
            "title": "Media"
        }, 
        {
            "location": "/data_models/#article", 
            "text": "The  Article  class represents a news item that can be displayed in the application. Depending on how you configure your Article on the Oddworks dashboard it can contain a description, a title, a preview image, a URL to link to, a category, a source, a created at timestamp, a related  Identifier  object, relationships, included  OddObject s (such as related articles), and a type.", 
            "title": "Article"
        }, 
        {
            "location": "/data_models/#event", 
            "text": "The  Event  class is similar to the  Article  class but it is used specifically for informing users of events that will or have occured. Depending on how you configure your Event on the Oddworks dashboard it can contain a description, a title, a preview image, a URL to link to, a category, a source, a created at timestamp, a start time, an end time, a location, a related  Identifier  object, relationships, included  OddObject s (such as related events), and a type. There is also the convienence methos of  isMultiDayEvent  in case you need to update your UI based on datetime formatting.", 
            "title": "Event"
        }, 
        {
            "location": "/data_models/#external", 
            "text": "The  External  class is used to handle any webpage you'd like to embed in your application. Depending on how you configure your External on the Oddworks dashboard it can contain a description, a title, a preview image, a URL to link to, a related  Identifier  object, relationships, included  OddObject s (such as related externals), and a type.", 
            "title": "External"
        }, 
        {
            "location": "/data_models/#promotion", 
            "text": "The  Promotion  class is used to handle any type of promotion you may want to put in the application. Depending on how you configure your Promotion on the Oddworks dashboard it can contain a description, a title, a preview image, a related  Identifier  object, relationships, included  OddObject s (such as related externals), and a type.", 
            "title": "Promotion"
        }, 
        {
            "location": "/initialize_api_calls/", 
            "text": "Get Config Data from API\n\n\nNote: We've configured the NASA test organization to send config information down with the use of \nOddView\ns as the main way of constructing data in the application. This is completely optional. You may format your data however you like on the Oddworks dashboard. For example: you may just want to call all collections or videos directly.\n\n\nNow it's time to make our \nSplashActivity\n actually do somthing. First we'll set up the member variables...\n\n\n// app/java/sample.oddworks.com.oddsampleapp/SplashActivity\n\n// ...\npublic class SplashActivity extends AppCompatActivity {\n    // Constants\n    private static final String HOME_VIEW_NAME = \nhome-view\n;\n\n    // Data\n    private RestServiceProvider restServiceProvider = RestServiceProvider.getInstance();\n    private ApiCaller apiCaller = restServiceProvider.getApiCaller();\n\n    // ...\n}\n\n\n\n\nThere's a new class that we're interacting with called \nApiCaller\n. This does exactly what it sounds like and is the class used to make calls to the API.\n\n\nThe first thing we'll want to do in our \nonCreate\n method after setting the content view is set our context.\n\n\n// app/java/sample.oddworks.com.oddsampleapp/SplashActivity\n\n// ...\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_splash);\n    context = this;\n}\n// ...\n\n\n\n\nThe next thing check to see if the application is connected to the internet. This method may be useful in other classes in our application so instead of creating a method for it in our \nSplashActivity\n we'll create a \nUtility\n class with a method to check if there is internet connectivity.\n\n\npackage sample.oddworks.com.myoddworksapplication;\n\nimport android.content.Context;\nimport android.net.ConnectivityManager;\n\npublic class Utility {\n    public static boolean hasInternetConnection(Context context) {\n        ConnectivityManager con_manager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);\n\n        if (con_manager.getActiveNetworkInfo() != null \n con_manager.getActiveNetworkInfo().isAvailable() \n con_manager.getActiveNetworkInfo().isConnected()) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n\n\n\nIn order for this to work, we'll need to add some permissions to our \nAndroidManifest\n file right before the opening \napplication\n tag.\n\n\n// app/manifests/AndroidManifest.xml\n\n\n    \nuses-permission android:name=\nandroid.permission.INTERNET\n /\n\n    \nuses-permission android:name=\nandroid.permission.ACCESS_NETWORK_STATE\n /\n\n\n\n\n\n\nNow we can check to see if the app has connectivity in the \nSplashActivity\n's \nonCreate\n method:\n\n\n``java\n// app/java/sample.oddworks.com.oddsampleapp/SplashActivity\n\n\n// ...\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_splash);\n    context = this;\n\n\nif (Utility.hasInternetConnection(getApplicationContext())) {\n    apiCaller.getConfig(new ConfigRequestCallback());\n} else {\n    // handle failure by notifying user on UI\n    // consider giving them a \"retry\" button\n    // perhaps via a Snackbar\n}\n\n\n\n}\n\n\nprivate final class ConfigRequestCallback implements OddCallback\n {\n    @Override\n    public void onSuccess(Config config) {\n        // handle success\n    }\n\n\n@Override\npublic void onFailure(final Exception exception) {\n    // handle failure\n}\n\n\n\n}\n// ...\n\n\n\nIf the app is connected to the internet we use the `apiCaller` to request configuration from the API and pass it a callback class that implements an `OddCallback`. If there's a failure we should notify the user of this and give them the option to retry. *Warning: if you try to manipulate the UI within this callback you will crash the application since you aren't running on the main thread. You must specify that you'd like to run on the main thread if you'd like to make any UI updates.*\n\n\n# Getting View Data from API\n\nAssuming the config request returns successful we can use the config object to set up many things about our app. For now, we'll only focus on the views that the config sends us.\n\n```java\n// app/java/sample.oddworks.com.oddsampleapp/SplashActivity\n\n// ...\nprivate final class ConfigRequestCallback implements OddCallback\nConfig\n {\n    @Override\n    public void onSuccess(Config config) {\n        Map\nString, String\n views = config.getViews();\n        String homeView = views.get(HOME_VIEW_NAME);\n\n        apiCaller.getView(homeView, new HomeViewRequestCallback(HOME_VIEW_NAME));\n    }\n\n    @Override\n    public void onFailure(final Exception exception) {\n        // handle failure\n    }\n}\n\nprivate final class HomeViewRequestCallback implements OddCallback\nOddView\n {\n\n    public HomeViewRequestCallback() {\n\n    }\n\n    @Override\n    public void onSuccess(OddView view) {\n        OddApp oddApp = OddApp.getInstance();\n\n        oddApp.setHomeView(view);\n    }\n\n    @Override\n    public void onFailure(final Exception exception) {\n        // handle failure\n    }\n\n    public String getViewType() {\n        return mViewType;\n    }\n}\n// ...\n\n\n\n\nHere, we're creating a custom \nOddCallback\n for the view that we're requesting through the \napiCaller\n. Remember, the setter methods for each view utilize the \nOddStore\n so we'll have access to this information throughout the app if the member variables in \nOddApp\n get collected from memory.\n\n\nThe last thing we need to do in our \nSplashActivity\n is launch a new Activity that will make use of all the data we've fetched. First we'll need to create a new Activity, we'll call ours \nHomeActivity\n. Now in the \nHomeViewRequestCallback\n section of our \nSplashActivity\n we'll make sure we have all our data and launch a new Intent:\n\n\n// ...\n@Override\npublic void onSuccess(OddView view) {\n    OddApp oddApp = OddApp.getInstance();\n\n    oddApp.setHomeView(view);\n\n    Intent home = new Intent(context, HomeActivity.class);\n    startActivity(home);\n}\n// ...", 
            "title": "Initialize API Calls"
        }, 
        {
            "location": "/initialize_api_calls/#get-config-data-from-api", 
            "text": "Note: We've configured the NASA test organization to send config information down with the use of  OddView s as the main way of constructing data in the application. This is completely optional. You may format your data however you like on the Oddworks dashboard. For example: you may just want to call all collections or videos directly.  Now it's time to make our  SplashActivity  actually do somthing. First we'll set up the member variables...  // app/java/sample.oddworks.com.oddsampleapp/SplashActivity\n\n// ...\npublic class SplashActivity extends AppCompatActivity {\n    // Constants\n    private static final String HOME_VIEW_NAME =  home-view ;\n\n    // Data\n    private RestServiceProvider restServiceProvider = RestServiceProvider.getInstance();\n    private ApiCaller apiCaller = restServiceProvider.getApiCaller();\n\n    // ...\n}  There's a new class that we're interacting with called  ApiCaller . This does exactly what it sounds like and is the class used to make calls to the API.  The first thing we'll want to do in our  onCreate  method after setting the content view is set our context.  // app/java/sample.oddworks.com.oddsampleapp/SplashActivity\n\n// ...\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_splash);\n    context = this;\n}\n// ...  The next thing check to see if the application is connected to the internet. This method may be useful in other classes in our application so instead of creating a method for it in our  SplashActivity  we'll create a  Utility  class with a method to check if there is internet connectivity.  package sample.oddworks.com.myoddworksapplication;\n\nimport android.content.Context;\nimport android.net.ConnectivityManager;\n\npublic class Utility {\n    public static boolean hasInternetConnection(Context context) {\n        ConnectivityManager con_manager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);\n\n        if (con_manager.getActiveNetworkInfo() != null   con_manager.getActiveNetworkInfo().isAvailable()   con_manager.getActiveNetworkInfo().isConnected()) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}  In order for this to work, we'll need to add some permissions to our  AndroidManifest  file right before the opening  application  tag.  // app/manifests/AndroidManifest.xml\n\n\n     uses-permission android:name= android.permission.INTERNET  / \n     uses-permission android:name= android.permission.ACCESS_NETWORK_STATE  /   Now we can check to see if the app has connectivity in the  SplashActivity 's  onCreate  method:  ``java\n// app/java/sample.oddworks.com.oddsampleapp/SplashActivity  // ...\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_splash);\n    context = this;  if (Utility.hasInternetConnection(getApplicationContext())) {\n    apiCaller.getConfig(new ConfigRequestCallback());\n} else {\n    // handle failure by notifying user on UI\n    // consider giving them a \"retry\" button\n    // perhaps via a Snackbar\n}  }  private final class ConfigRequestCallback implements OddCallback  {\n    @Override\n    public void onSuccess(Config config) {\n        // handle success\n    }  @Override\npublic void onFailure(final Exception exception) {\n    // handle failure\n}  }\n// ...  \nIf the app is connected to the internet we use the `apiCaller` to request configuration from the API and pass it a callback class that implements an `OddCallback`. If there's a failure we should notify the user of this and give them the option to retry. *Warning: if you try to manipulate the UI within this callback you will crash the application since you aren't running on the main thread. You must specify that you'd like to run on the main thread if you'd like to make any UI updates.*\n\n\n# Getting View Data from API\n\nAssuming the config request returns successful we can use the config object to set up many things about our app. For now, we'll only focus on the views that the config sends us.\n\n```java\n// app/java/sample.oddworks.com.oddsampleapp/SplashActivity\n\n// ...\nprivate final class ConfigRequestCallback implements OddCallback Config  {\n    @Override\n    public void onSuccess(Config config) {\n        Map String, String  views = config.getViews();\n        String homeView = views.get(HOME_VIEW_NAME);\n\n        apiCaller.getView(homeView, new HomeViewRequestCallback(HOME_VIEW_NAME));\n    }\n\n    @Override\n    public void onFailure(final Exception exception) {\n        // handle failure\n    }\n}\n\nprivate final class HomeViewRequestCallback implements OddCallback OddView  {\n\n    public HomeViewRequestCallback() {\n\n    }\n\n    @Override\n    public void onSuccess(OddView view) {\n        OddApp oddApp = OddApp.getInstance();\n\n        oddApp.setHomeView(view);\n    }\n\n    @Override\n    public void onFailure(final Exception exception) {\n        // handle failure\n    }\n\n    public String getViewType() {\n        return mViewType;\n    }\n}\n// ...  Here, we're creating a custom  OddCallback  for the view that we're requesting through the  apiCaller . Remember, the setter methods for each view utilize the  OddStore  so we'll have access to this information throughout the app if the member variables in  OddApp  get collected from memory.  The last thing we need to do in our  SplashActivity  is launch a new Activity that will make use of all the data we've fetched. First we'll need to create a new Activity, we'll call ours  HomeActivity . Now in the  HomeViewRequestCallback  section of our  SplashActivity  we'll make sure we have all our data and launch a new Intent:  // ...\n@Override\npublic void onSuccess(OddView view) {\n    OddApp oddApp = OddApp.getInstance();\n\n    oddApp.setHomeView(view);\n\n    Intent home = new Intent(context, HomeActivity.class);\n    startActivity(home);\n}\n// ...", 
            "title": "Get Config Data from API"
        }
    ]
}